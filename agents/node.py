import typing
import re

from dotenv import load_dotenv
from .state import AgentState
from app.auth import get_installation_token
from langchain_google_genai import ChatGoogleGenerativeAI
import os
from langchain_core.prompts import ChatPromptTemplate, HumanMessagePromptTemplate, SystemMessagePromptTemplate
load_dotenv()
def researcher_node(state: "AgentState"):
    print("--- üîçRESEARCHER AGENT HAS BEEN CALLED üîç ---")

    # 1. Path Identification (Your Regex is working great!)
    error_msg = state.get("errorMessage", "")
    match = re.search(r'File "([^"]+\.py)"', error_msg)
    file_path = match.group(1) if match else state.get("file_path")
    
    if not file_path:
        return {"logs": state["logs"] + ["Researcher failed to identify file path."]}

    print(f"üìÇ Identified target file: {file_path}")

    # 2. FETCH CONTENT WITH SAFETY CHECKS
    gh = get_installation_token(state["installation_id"])
    
    # NEW: Check if gh actually exists before calling get_repo
    if gh is None:
        print("‚ùå GITHUB AUTH FAILED: gh is None")
        return {"logs": state["logs"] + ["Researcher failed: GitHub authentication returned None."]}

    try:
        repo = gh.get_repo(state["repo_name"])
        clean_path = file_path.split('/')[-1] if "/" in file_path else file_path
        file_content = repo.get_contents(clean_path).decoded_content.decode()
        
        return {
            "sourceCode": file_content,
            "file_path": clean_path,
            "logs": state["logs"] + [f"Researcher fetched {clean_path}."],
        }
    except Exception as e:
        print(f"‚ùå REPO FETCH FAILED: {str(e)}")
        return {"logs": state["logs"] + [f"Error accessing repo or file: {str(e)}"]}

def coder_node(state: "AgentState"):
    print("--- üíªCODER AGENT HAS BEEN CALLED üíª ---")
    
    # Note: Using Gemini 1.5 Pro or Flash is excellent for long-context code tasks
    llm = ChatGoogleGenerativeAI(model="gemini-2.5-flash", temperature=0, api_key=os.getenv("GEMINI_API_KEY"))
    
    prompt = ChatPromptTemplate.from_messages([
        SystemMessagePromptTemplate.from_template(
            "You are an expert Python Engineer. Fix the code to handle edge cases "
            "like empty lists or null inputs. Return ONLY the corrected code for the specific file. "
            "Do not include markdown backticks or explanations."
        ),
        HumanMessagePromptTemplate.from_template(
            "File Path: {file_path}\n"
            "Source Code:\n{sourceCode}\n\n"
            "Error Message:\n{errorMessage}\n\n"
            "Propose a full-file fix:"
        ),
    ])
    
    chain = prompt | llm
    response = chain.invoke({
        "file_path": state.get("file_path", "unknown"),
        "sourceCode": state["sourceCode"],
        "errorMessage": state["errorMessage"]
    })

    return {
        "proposedFix": response.content,
        "logs": state["logs"] + [f"Coder proposed a fix for {state.get('file_path')}"],
    }

def pr_creator_node(state: "AgentState"):
    print("--- üì¨PR CREATOR AGENT HAS BEEN CALLED üì¨ ---")
    
    gh = get_installation_token(state["installation_id"])
    
    if gh is None:
        print("‚ùå GITHUB AUTH FAILED: gh is None")
        return {"logs": state["logs"] + ["PR Creator failed: GitHub authentication returned None."]}

    try:
        repo = gh.get_repo(state["repo_name"])
        branch_name = f"autopatch-fix-{state['file_path'].replace('.', '-')}"
        base_branch = repo.default_branch

        sh = repo.get_branch(base_branch)
        repo.create_git_ref(ref=f"refs/heads/{branch_name}", sha=sh.commit.sha)

        current_file = repo.get_contents(state["file_path"], ref=branch_name)
        repo.update_file(
            path=state["file_path"],
            message="AutoPatch.ai: Applying automated fix",
            content=state["proposedFix"],
            sha=current_file.sha,
            branch=branch_name
        )

        pr = repo.create_pull(
            title="AutoPatch.ai: Automated Code Fix",
            body="This PR contains an automated fix generated by AutoPatch.ai to address CI/CD failures.",
            head=branch_name,
            base=base_branch
        )
        return {
            "logs": state["logs"] + [f"PR created: {pr.html_url}"],
        }
    except Exception as e:
        print(f"‚ùå PR CREATION FAILED: {str(e)}")
        return {"logs": state["logs"] + [f"Error creating PR: {str(e)}"]}